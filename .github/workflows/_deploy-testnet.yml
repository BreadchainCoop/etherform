# Reusable testnet deployment workflow
# Usage: jobs.<job>.uses: ./.github/workflows/_deploy-testnet.yml
name: Deploy Testnet (Reusable)

on:
  workflow_call:
    inputs:
      deployment-foundry-profile:
        description: 'Foundry profile to use for deployment (must be defined in foundry.toml)'
        type: string
        default: ''
      deploy-script:
        description: 'Path to deployment script'
        type: string
        default: 'script/Deploy.s.sol:Deploy'
      network-config-path:
        description: 'Path to network configuration JSON'
        type: string
        default: '.github/deploy-networks.json'
      network-index:
        description: 'Index in testnets array to deploy to'
        type: number
        default: 0
      indexing-wait:
        description: 'Seconds to wait for indexer before verification'
        type: number
        default: 60
    secrets:
      PRIVATE_KEY:
        required: true
      RPC_URL:
        required: true

jobs:
  deploy-testnet:
    name: Deploy to Testnet
    runs-on: ubuntu-latest
    env:
      FOUNDRY_PROFILE: ${{ inputs.deployment-foundry-profile }}
    outputs:
      network_name: ${{ steps.network.outputs.network_name }}
      blockscout_url: ${{ steps.network.outputs.blockscout_url }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Read network config
        id: network
        run: |
          BLOCKSCOUT_URL=$(jq -r '.testnets[${{ inputs.network-index }}].blockscout_url' ${{ inputs.network-config-path }})
          NETWORK_NAME=$(jq -r '.testnets[${{ inputs.network-index }}].name' ${{ inputs.network-config-path }})
          echo "blockscout_url=$BLOCKSCOUT_URL" >> $GITHUB_OUTPUT
          echo "network_name=$NETWORK_NAME" >> $GITHUB_OUTPUT

      - name: Deploy contracts
        env:
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          RPC_URL: ${{ secrets.RPC_URL }}
        run: |
          # Ensure PRIVATE_KEY has 0x prefix
          if [[ "$PRIVATE_KEY" != 0x* ]]; then
            export PRIVATE_KEY="0x$PRIVATE_KEY"
          fi
          forge script ${{ inputs.deploy-script }} \
            --rpc-url "$RPC_URL" \
            --broadcast \
            --slow \
            -vvvv

      - name: Wait for indexing
        run: sleep ${{ inputs.indexing-wait }}

      - name: Parse deployment addresses
        id: parse
        run: |
          # Find the latest broadcast file
          BROADCAST_FILE=$(find broadcast -name "run-latest.json" -type f | head -1)
          if [[ -z "$BROADCAST_FILE" ]]; then
            echo "No broadcast file found"
            exit 1
          fi
          echo "broadcast_file=$BROADCAST_FILE" >> $GITHUB_OUTPUT

          # Extract deployed contract addresses
          jq -r '.transactions[] | select(.transactionType == "CREATE") | "\(.contractName): \(.contractAddress)"' "$BROADCAST_FILE" | tee deployment-summary.txt

      - name: Verify contracts on Blockscout
        if: steps.network.outputs.blockscout_url != ''
        env:
          BLOCKSCOUT_URL: ${{ steps.network.outputs.blockscout_url }}
        run: |
          BROADCAST_FILE="${{ steps.parse.outputs.broadcast_file }}"

          # Extract and verify each deployed contract with retry logic
          jq -c '.transactions[] | select(.transactionType == "CREATE")' "$BROADCAST_FILE" | while read -r tx; do
            CONTRACT_NAME=$(echo "$tx" | jq -r '.contractName')
            CONTRACT_ADDR=$(echo "$tx" | jq -r '.contractAddress')

            echo "Verifying $CONTRACT_NAME at $CONTRACT_ADDR..."

            # Retry up to 3 times with exponential backoff
            # Use --guess-constructor-args to auto-detect from on-chain bytecode
            for attempt in 1 2 3; do
              if forge verify-contract "$CONTRACT_ADDR" "$CONTRACT_NAME" \
                --verifier blockscout \
                --verifier-url "${BLOCKSCOUT_URL}/api" \
                --guess-constructor-args \
                --watch; then
                echo "✓ Verified $CONTRACT_NAME"
                break
              else
                if [[ $attempt -lt 3 ]]; then
                  echo "Attempt $attempt failed, retrying in $((attempt * 30))s..."
                  sleep $((attempt * 30))
                else
                  echo "⚠ Verification pending for $CONTRACT_NAME after 3 attempts"
                fi
              fi
            done
          done

      - name: Save deployment artifacts
        run: |
          mkdir -p deployments/${{ steps.network.outputs.network_name }}
          BROADCAST_FILE="${{ steps.parse.outputs.broadcast_file }}"

          # Extract contracts with proper sourcePathAndName format
          jq '{contracts: [.transactions[] | select(.transactionType == "CREATE") | {sourcePathAndName: "src/\(.contractName).sol:\(.contractName)", address: .contractAddress}]}' "$BROADCAST_FILE" \
            > deployments/${{ steps.network.outputs.network_name }}/deployment.json

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ steps.network.outputs.network_name }}
          path: deployments/

      - name: Create deployment summary
        env:
          BLOCKSCOUT_URL: ${{ steps.network.outputs.blockscout_url }}
        run: |
          echo "## Testnet Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Contract | Address | Explorer |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|---------|----------|" >> $GITHUB_STEP_SUMMARY

          while read -r line; do
            CONTRACT=$(echo "$line" | cut -d: -f1)
            ADDRESS=$(echo "$line" | cut -d: -f2 | tr -d ' ')
            echo "| $CONTRACT | \`$ADDRESS\` | [View](${BLOCKSCOUT_URL}/address/$ADDRESS) |" >> $GITHUB_STEP_SUMMARY
          done < deployment-summary.txt
