# Foundry Upgrade Safety Validation
# Usage: jobs.<job>.uses: BreadchainCoop/etherform/.github/workflows/_foundry-upgrade-safety.yml@main
name: Upgrade Safety

on:
  workflow_call:
    inputs:
      baseline-path:
        description: 'Path to baseline contracts for upgrade comparison'
        type: string
        default: 'test/upgrades/baseline'
      upgrades-path:
        description: 'Path for flattened contract snapshots'
        type: string
        default: 'test/upgrades'
      working-directory:
        description: 'Working directory for Foundry commands'
        type: string
        default: '.'

jobs:
  validate:
    name: Upgrade Safety
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Run upgrade safety validation
        env:
          BASELINE_PATH: ${{ inputs.baseline-path }}
          UPGRADES_PATH: ${{ inputs.upgrades-path }}
        run: |
          set -euo pipefail

          # Determine which baseline directory to use
          FALLBACK="${UPGRADES_PATH}/previous"

          if [ -d "$BASELINE_PATH" ] && ls ${BASELINE_PATH}/*.sol 1> /dev/null 2>&1; then
            BASELINE_DIR="$BASELINE_PATH"
          elif [ -d "$FALLBACK" ] && ls ${FALLBACK}/*.sol 1> /dev/null 2>&1; then
            BASELINE_DIR="$FALLBACK"
          else
            echo "::warning::Baseline missing — will auto-init on first merge to main"
            echo "No baseline contracts found, skipping upgrade validation (initial deployment)"
            exit 0
          fi

          echo "Using baseline directory: $BASELINE_DIR"

          # Generate validation script dynamically
          mkdir -p script/generated
          cat > script/generated/ValidateUpgrades.s.sol << 'SOLEOF'
          // SPDX-License-Identifier: MIT
          pragma solidity ^0.8.13;

          import {Script} from "forge-std/Script.sol";
          import {Options} from "openzeppelin-foundry-upgrades/Options.sol";
          import {Upgrades} from "openzeppelin-foundry-upgrades/Upgrades.sol";

          contract ValidateUpgrades is Script {
              function run(string calldata currentContract, string calldata referenceContract) external {
                  Options memory opts;
                  opts.referenceContract = referenceContract;
                  Upgrades.validateUpgrade(currentContract, opts);
              }
          }
          SOLEOF

          forge build

          FAILED=0

          # Validate each contract in the baseline
          for baseline_file in ${BASELINE_DIR}/*.sol; do
            CONTRACT_NAME=$(basename "$baseline_file" .sol)

            # Find the current source file
            CURRENT_FILE=$(find src -name "${CONTRACT_NAME}.sol" -type f 2>/dev/null | head -1)
            if [[ -z "$CURRENT_FILE" ]]; then
              echo "::warning::No current source found for $CONTRACT_NAME, skipping"
              continue
            fi

            CURRENT_CONTRACT="${CURRENT_FILE}:${CONTRACT_NAME}"
            REFERENCE_CONTRACT="${BASELINE_DIR}/${CONTRACT_NAME}.sol:${CONTRACT_NAME}"

            echo "Validating upgrade: $CURRENT_CONTRACT <- $REFERENCE_CONTRACT"

            if forge script script/generated/ValidateUpgrades.s.sol \
              --sig "run(string,string)" "$CURRENT_CONTRACT" "$REFERENCE_CONTRACT" \
              -vvv; then
              echo "✓ ${CONTRACT_NAME} upgrade is safe"
            else
              echo "::error::${CONTRACT_NAME} upgrade validation failed"
              FAILED=1
            fi
          done

          # Cleanup generated script
          rm -rf script/generated

          if [[ $FAILED -eq 1 ]]; then
            echo "::error::One or more contracts failed upgrade safety validation"
            exit 1
          fi

          echo "All contracts passed upgrade safety validation"
