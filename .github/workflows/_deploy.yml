# Reusable deployment workflow for Foundry projects
# Handles both testnet and mainnet deployments with optional matrix and snapshots
# Usage: jobs.<job>.uses: ./.github/workflows/_deploy.yml
name: Deploy (Reusable)

on:
  workflow_call:
    inputs:
      environment-type:
        description: 'Environment type: testnet or mainnet'
        type: string
        required: true
      network:
        description: 'Specific network name to deploy to (leave empty for all networks of the environment type)'
        type: string
        default: ''
      deploy-script:
        description: 'Path to deployment script'
        type: string
        default: 'script/Deploy.s.sol:Deploy'
      network-config-path:
        description: 'Path to network configuration JSON'
        type: string
        default: '.github/deploy-networks.json'
      indexing-wait:
        description: 'Seconds to wait for indexer before verification'
        type: number
        default: 60
      enable-snapshots:
        description: 'Flatten and commit contract snapshots after deploy (recommended for mainnet)'
        type: boolean
        default: false
      upgrades-path:
        description: 'Path to store flattened contract snapshots'
        type: string
        default: 'test/upgrades'
    secrets:
      PRIVATE_KEY:
        required: true
      RPC_URL:
        required: true
      GH_TOKEN:
        description: 'GitHub token for pushing commits (required if enable-snapshots is true)'
        required: false

jobs:
  read-config:
    name: Read Network Config
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has-networks: ${{ steps.set-matrix.outputs.has-networks }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set deployment matrix
        id: set-matrix
        run: |
          CONFIG_PATH="${{ inputs.network-config-path }}"
          ENV_TYPE="${{ inputs.environment-type }}"
          NETWORK="${{ inputs.network }}"

          # Select array based on environment type
          if [[ "$ENV_TYPE" == "mainnet" ]]; then
            ARRAY_KEY="mainnets"
          else
            ARRAY_KEY="testnets"
          fi

          # Build matrix - filter to specific network if provided
          if [[ -n "$NETWORK" ]]; then
            MATRIX=$(jq -c --arg net "$NETWORK" --arg key "$ARRAY_KEY" \
              '{include: [.[$key][] | select(.name == $net)]}' "$CONFIG_PATH")
          else
            MATRIX=$(jq -c --arg key "$ARRAY_KEY" '{include: .[$key]}' "$CONFIG_PATH")
          fi

          # Check if we have any networks to deploy to
          NETWORK_COUNT=$(echo "$MATRIX" | jq '.include | length')
          if [[ "$NETWORK_COUNT" -eq 0 ]]; then
            echo "has-networks=false" >> $GITHUB_OUTPUT
            echo "::warning::No networks found for environment type '$ENV_TYPE'"
          else
            echo "has-networks=true" >> $GITHUB_OUTPUT
          fi

          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Deployment matrix: $MATRIX"

  deploy:
    name: Deploy to ${{ matrix.name }}
    runs-on: ubuntu-latest
    needs: [read-config]
    if: needs.read-config.outputs.has-networks == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.read-config.outputs.matrix) }}
    environment: ${{ matrix.environment }}
    outputs:
      deployed: ${{ steps.deploy.outcome == 'success' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Deploy contracts
        id: deploy
        env:
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
          RPC_URL: ${{ secrets.RPC_URL }}
        run: |
          # Ensure PRIVATE_KEY has 0x prefix
          if [[ "$PRIVATE_KEY" != 0x* ]]; then
            export PRIVATE_KEY="0x$PRIVATE_KEY"
          fi
          forge script ${{ inputs.deploy-script }} \
            --rpc-url "$RPC_URL" \
            --broadcast \
            --slow \
            -vvvv

      - name: Wait for indexing
        run: sleep ${{ inputs.indexing-wait }}

      - name: Parse deployment addresses
        id: parse
        run: |
          BROADCAST_FILE=$(find broadcast -name "run-latest.json" -type f | head -1)
          if [[ -z "$BROADCAST_FILE" ]]; then
            echo "No broadcast file found"
            exit 1
          fi
          echo "broadcast_file=$BROADCAST_FILE" >> $GITHUB_OUTPUT

          jq -r '.transactions[] | select(.transactionType == "CREATE") | "\(.contractName): \(.contractAddress)"' \
            "$BROADCAST_FILE" | tee deployment-summary.txt

      - name: Verify contracts on Blockscout
        env:
          BLOCKSCOUT_URL: ${{ matrix.blockscout_url }}
        run: |
          BROADCAST_FILE="${{ steps.parse.outputs.broadcast_file }}"

          jq -c '.transactions[] | select(.transactionType == "CREATE")' "$BROADCAST_FILE" | while read -r tx; do
            CONTRACT_NAME=$(echo "$tx" | jq -r '.contractName')
            CONTRACT_ADDR=$(echo "$tx" | jq -r '.contractAddress')

            echo "Verifying $CONTRACT_NAME at $CONTRACT_ADDR..."

            for attempt in 1 2 3; do
              if forge verify-contract "$CONTRACT_ADDR" "$CONTRACT_NAME" \
                --verifier blockscout \
                --verifier-url "${BLOCKSCOUT_URL}/api" \
                --guess-constructor-args \
                --watch; then
                echo "Verified $CONTRACT_NAME"
                break
              else
                if [[ $attempt -lt 3 ]]; then
                  echo "Attempt $attempt failed, retrying in $((attempt * 30))s..."
                  sleep $((attempt * 30))
                else
                  echo "Verification pending for $CONTRACT_NAME after 3 attempts"
                fi
              fi
            done
          done

      - name: Save deployment artifacts
        run: |
          mkdir -p deployments/${{ matrix.name }}
          BROADCAST_FILE="${{ steps.parse.outputs.broadcast_file }}"

          jq '{contracts: [.transactions[] | select(.transactionType == "CREATE") | {sourcePathAndName: "src/\(.contractName).sol:\(.contractName)", address: .contractAddress}]}' \
            "$BROADCAST_FILE" > deployments/${{ matrix.name }}/deployment.json

      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ matrix.name }}
          path: deployments/

      - name: Create deployment summary
        env:
          BLOCKSCOUT_URL: ${{ matrix.blockscout_url }}
        run: |
          echo "## ${{ matrix.name }} Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Contract | Address | Explorer |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|---------|----------|" >> $GITHUB_STEP_SUMMARY

          while read -r line; do
            CONTRACT=$(echo "$line" | cut -d: -f1)
            ADDRESS=$(echo "$line" | cut -d: -f2 | tr -d ' ')
            echo "| $CONTRACT | \`$ADDRESS\` | [View](${BLOCKSCOUT_URL}/address/$ADDRESS) |" >> $GITHUB_STEP_SUMMARY
          done < deployment-summary.txt

  flatten-snapshots:
    name: Flatten & Commit Snapshots
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success() && inputs.enable-snapshots
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive
          token: ${{ secrets.GH_TOKEN || github.token }}

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Download all deployment artifacts
        uses: actions/download-artifact@v4
        with:
          path: deployments-downloaded

      - name: Build contracts
        run: forge build

      - name: Extract contract list from broadcast artifacts
        id: contracts
        run: |
          CONTRACTS=$(find broadcast -name "run-latest.json" -type f -exec \
            jq -r '.transactions[] | select(.transactionType == "CREATE") | "src/\(.contractName).sol"' {} \; 2>/dev/null | sort -u)

          if [[ -z "$CONTRACTS" ]]; then
            echo "No contracts found in broadcast artifacts, falling back to src/*.sol"
            CONTRACTS=$(find src -maxdepth 1 -type f -name "*.sol")
          fi

          echo "Contracts to flatten:"
          echo "$CONTRACTS"
          echo "contracts<<EOF" >> $GITHUB_OUTPUT
          echo "$CONTRACTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Flatten contracts to current snapshot
        env:
          UPGRADES_PATH: ${{ inputs.upgrades-path }}
        run: |
          mkdir -p "${UPGRADES_PATH}/current"

          echo "${{ steps.contracts.outputs.contracts }}" | while read -r contract; do
            if [[ -f "$contract" ]]; then
              name=$(basename "$contract")
              echo "Flattening $contract..."
              forge flatten "$contract" > "${UPGRADES_PATH}/current/$name"
            fi
          done

          echo "Flattened contracts saved to ${UPGRADES_PATH}/current/"

      - name: Promote snapshots (3-tier rotation)
        env:
          UPGRADES_PATH: ${{ inputs.upgrades-path }}
        run: |
          if [[ -d "${UPGRADES_PATH}/baseline" ]] && ls ${UPGRADES_PATH}/baseline/*.sol 1> /dev/null 2>&1; then
            echo "Baseline exists, performing 3-tier rotation..."

            rm -rf "${UPGRADES_PATH}/previous"
            cp -r "${UPGRADES_PATH}/baseline" "${UPGRADES_PATH}/previous"
            echo "Copied baseline to previous"

            rm -rf "${UPGRADES_PATH}/baseline"
            cp -r "${UPGRADES_PATH}/current" "${UPGRADES_PATH}/baseline"
            echo "Copied current to baseline"

            COMMIT_MSG="chore: auto-flatten contracts after deploy [skip ci]"
          else
            echo "No baseline found, initializing baseline from current..."

            mkdir -p "${UPGRADES_PATH}/baseline"
            cp -r "${UPGRADES_PATH}/current/"* "${UPGRADES_PATH}/baseline/"
            echo "Initialized baseline from current"

            COMMIT_MSG="chore: init upgrade baseline [skip ci]"
          fi

          echo "commit_msg=$COMMIT_MSG" >> $GITHUB_ENV

      - name: Commit flattened contracts
        env:
          UPGRADES_PATH: ${{ inputs.upgrades-path }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add "${UPGRADES_PATH}/" || true

          if git diff --staged --quiet; then
            echo "No snapshot changes to commit"
          else
            git commit -m "$commit_msg"
            git push
          fi
